\chapter{Úvod}
Booleova algebra má značné využitie vo viacerých oblastiach vedy. Jej základným a dnes hlavným využitím je binárna reprezentácia stavov tranzistorov v počítačovej vede, a tým pádov využitie jediného bitu. Okrem toho ale svoje využitie nachádza aj pri návrhu číslicových obvodov ako efektívna reprezentácia chovania jednotlivých harvérových komponentov, v teórií grafov pre návrh orientovaných grafov, či v klasickom high-level programovaní ako vyjadrenie rôznych stavov systému.

Bohaté využitie má takisto aj v matematike vo výrokovej logike a kombinatorike. Uplatnenie booleovej algebry je možné vidieť aj v oblasti umelej inteligencie, teórie mechanického učenia a teórie hier. Z netechnických odborov stojí za zmienku oblasť legislatívy, kde sa využíva booleova logika napríklad pri voľbách do štátnych funkcií.

Existujú viaceré reprezentácie booleovskych funkcií, ktoré sa líšia svojím využitíme. Klasické reprezentácie formou pravdivostných tabuliek nachádzajú svoje využitie v matematike, ale pre informatiku nie sú vhodné. V priebehu času boli vyvinuté rôzne metódy pre symbolizáciu týchto funkcií v počítačovom programe, z nich najpoužívanejšia je reprezentácia binárnymi rozhodovacími diagramami (skrátene BDD z anglického Binary Decision Diagram). Jednou z výhod reprezentácie pomocou BDD je, že dokážu vytvoriť kanonickú formu funkcie. BDD umožňujú veľmi dobre zisťovať ekvivalenciu a splniteľnosť booleovskych funkcií.

Reprezentácia pomocou BDD v informatike je síce najrozšírenejšia, ale booleovske funkcie sa dajú reprezentovať aj inou formou. V tejto práci sa budeme zaoberať reprezentáciou boolevskych funkcií pomocou algebraickej normálnej formy (skrátene ANF). ANF poskytuje výhodu oproti BDD v tom, že obsahuje len operácie AND a XOR, a tým pádom sa jej implementácia značne zjednodušuje. Takisto je z ANF možné rýchlo vyčítať hodnotu danej funkcie, a takisto vypočítať jej splniteľnosť v rozumnom čase. 

Vytvorená knižnica poskytuje prostriedky pre efektívnu manipuláciu a zobrazovanie booleovskych funkcií v ANF. Motiváciou pre vytvorenie knižnice bolo vytvoriť slušnú alternatívu pre klasické reprezentácie pomocou BDD pre špecifické problémy, ktoré nepotrebujú komplexnuú reprezentáciu BDD, ale vystačia si aj s ANF.

V tejto práci si v kapitole \ref{chapter_theory} povieme najskôr niečo teoreticky o rôznych reprezentáciách booleovskych funkcií, o ich výhodách a necýhodách. V kapitole \ref{chapter_libraries} si odprezentujeme existujúce knižnice a ich využitie v praxi. V kapitole \ref{chapter_concept} sa budeme zaoberať technickým návrhom knižnice, v kapitole \ref{chapter_impl} jej konkrétnou implementáciou. Na záver si v kapitole \ref{chapter_result} porovnáme vytvorenú knižnicu s existujúcimi a vyvodíme z toho závery. 
 

\chapter{Booleovske funkcie} \label{chapter_theory}
V tejto kapitole sa nachádza teoretický úvod do problematiky booleovskych funkcií, postupne bude definované čo vlastne sú booleovske funkcie, čo sa dá pomocou nich popísať a aký môže byť ich obsah. Ďalej budú popísané rôzne možnosti zobrazenia booleovskych funkcií napríklad pravdivostné tabuľky a ďalšie. Kapitola takisto definuje rôzne normalizované formy zápisu booleovskych funkcií, pričom dôraz bude kladený hlavne na algebraickú normálnu formu, ktorej reprezentácia je cieľom celej práce. Podrobnejšie bude popísaná aj reprezentácia binárnymi rozhodovacími diagramami, ktoré sú momentálne najpoužívanejšou reprezentáciou v oblasti počítačovej vedy.

\section{Definícia booleovskej funkcie}
Ako uvádza Crama \cite{Crama-bool}, booleovská funkcia je každá funkcia $f: \mathcal{B}^{n} \rightarrow \mathcal{B}$, kde $\mathcal{B}$ je množina $\{0,1\}$, v ktorej $n$ je kladné prirodzené číslo, a $\mathcal{B}^{n}$ označuje $n$-násobný kartézsky súčin množiny $\mathcal{B}$ samej so sebou. Každý bod funkcie $X^*$ = ($x_1,x_2, \ldots, x_n$) naberá hodnotu buď 0 alebo 1 z množiny $\mathcal{B}$.

Celkový počet rôznych booleovskych funkcií pre $n$ premenných je $2^{2^n}$. Je to dané tým, že všetkých možných kombinácií vstupných parametrov je ($2^n$) a parametre môžu mať hodnotu z $\{0,1\}$. Tento počet obsahuje aj kombináciu o 0 prvkoch, takže sa častejšie uvádza číslo $2^{2^n-1}$. Počet možných booleovských funkcií pre niektoré hodnoty $n$ sa nachádza v Tabuľke {\ref{table:functionCountExample}}. Je vidieť že počet možných kombinácií prudko narastá s počtom premenných, a teda efektívna reprezentácia je nutnosťou.

\begin{table}[h]
	\centering
	\begin{tabular}{|r|l|} \hline
		n & počet funkcií \\ \hline
		1 & 4   \\
		2 & 16  \\
		3 & 256 \\
		5 & 4.29497 $\times 10^9$ \\ 
		6 & 1.84467 $\times 10^{19}$ \\ \hline
	\end{tabular}
	\caption{Počet booleovských funkcií pre vybrané hodnoty $n$}
	\label{table:functionCountExample}
\end{table}

V mnohých aplikáciách sa pre predstavu hodnôt množiny $\mathcal{B}$ namiesto dvojice \{0,1\} používa iná dvojica, napríklad \{true,false\}, \{1,-1\}, \{on,off\}, \{áno,nie\}, vždy to ale označuje opačné hodnoty. 
Množina $\mathcal{B}$ spolu so základnými booleovskymi operáciami konjunkciou $\wedge$, disjunkciou $\vee$ a negáciou $\neg$ tvorí Booleovsku algebru. Tieto operácie majú podobne ako dvojica \{0,1\} viacero používaných zápisov, napríklad \{$\cap, \cup, -$\} alebo \{$+, \cdot, -$\}\cite{Koppelberg-bool}. Booleovskú algebru tvorí niekoľko základných pravidiel, ktoré sú popísané v Tabuľke \ref{table:boolAlgebra}.

\begin{table}[h]
	\centering
	\begin{tabular}{|l l|} \hline
		asociativita & $(x \vee y) \vee z = x \vee (y \vee z)$ \\
		& $(x \wedge y) \wedge z = x \wedge (y \wedge z)$ \\
		komutativita &  $x \vee y = y \vee x$ \\
		& $x \wedge y = y \wedge x$ \\
		absorpcia & $x \vee (x \wedge y) = x$ \\
		& $x \wedge (x \vee y) = x$ \\
		distributívnosť & $x \vee (y \wedge z) = (x \vee y) \wedge (x \vee z)$ \\
		& $x \wedge (y \vee z) = x \wedge y \vee x \wedge z$ \\
		komplementarita & $x \vee \neg x = 1$ \\
		&  $x \wedge \neg x = 0$ \\  
		agresivita nuly & $x \wedge 0 = 0$ \\
		agresivita jednotky & $x \vee 1 = 1$ \\
		idempotencia & $x \vee x = x$ \\
		& $x \wedge x = x$ \\ 
		absorpcia negácie & $x \vee (\neg x \wedge y) = x \vee y$ \\
		& $x \wedge (\neg x \vee y) = x \wedge y$ \\ 
		dvojitá negácia & $\neg (\neg x) = x$ \\ 
		De Morganove zákony & $\neg x \wedge \neg y = \neg (x \vee y)$ \\
		& $\neg x \vee \neg y = \neg (x \wedge y)$ \\ \hline
	\end{tabular}
	\caption{Pravidlá Boolovskej algebry}
	\label{table:boolAlgebra}
\end{table}

Operáciou, ktorá nepatrí do trojice základných booleovskych operácií, ale v programovaní má svoje veľké využitie je XOR. Je možné ho vytvoriť kombináciou ostatných operácií. Využíva sa napríklad pri konštrukcií obvodov alebo v generátoroch pseudonáhodných čísel. 
\section{Reprezentácia booleovskych funkcií}
Booleovske funkcie môžu byť vyjadrené rôznymi spôsobmi. Záleží hlavne na tom, čo plánujeme s danou funkciou robiť. Niektoré zápisy sú vhodnejšie na matematické výpočty, iné zase na prehľadné prezeranie dát. 

\vspace*{0.5\baselineskip}
Prvým možným zápisom je pravdivostná tabuľka. Je to tabuľka, v ktorej na každom riadku je hodnota funkcie pri inú kombináciu vstupných hodnôt funkcie. Pravdivostné tabuľky majú dobré využitie pre funkcie do 3-4 parametrov. Pre vyšší počet parametrov sa stávajú neprehľadnými pre vysoký počet možných kombinácií. Príklad pravdivostnej tabuľky pre 2 vstupné hodnoty sa nachádza v Tabuľke \ref{table:truthTable}. 

\begin{table}[h]
	\centering
	\begin{tabular}{|c|c|} \hline
		$(x_1,x_2)$ & $f(x_1,x_2)$ \\ \hline
		$(0,0)$ & 0 \\
		$(0,1)$ & 1 \\
		$(1,0)$ & 1 \\
		$(1,1)$ & 0 \\ \hline
	\end{tabular}
	\caption{Pravdivostná tabuľka}
	\label{table:truthTable}
\end{table}

Upravenou formou pravdivostnej tabuľky je Karnaughova mapa. Je to forma zápisu ktorá prevádza n-rozmernú booleovsku funkciu do 2-rozmernej. Jej výhdou je, že sa pomocou nej dá funkcia pekne vizualizovať, do 5 premenných poskytuje stále dobrú predstavu. Využíva sa hlavne pri minimalizácii funkcií. Je vhodná pre ľudskú predstavu funkcie, pre počítač existujú efektívnejšie alternatívy. Príklad Karnaughovej mapy sa nachádza na Obrázku \ref{picture:KarnaughMap}.


Ďalším zo zápisov je logický obvod. Ide o schému, ktorá graficky zobrazuje booleovsku funkciu. Tento zápis je vhodnejší pre fyzikálne zamerané úlohy, alebo pre pokročilejšie úlohy, ktoré obsahujú zložitejšie funkcie, a tie sa dajú prehľadne zobraziť logickým obvodom. Logický obvod narozdiel od predošlých reprezentácií neukazuje všetky možné kombinácie hodnôt, ale len štruktúru danej funkcie. Dá sa použiť aj pre reprezentáciu funkcie o viacerých premenných než predošlé alternatívy. Príklad zobrazenia funkcie $(A \wedge B) \vee C$ vidíme na Obrázku \ref{picture:logicalCircuit}.

\begin{figure}[ht]
	\centering
	\begin{minipage}{.5\textwidth}
		\centering
		{\includegraphics{obrazky-figures/KarnaughMap.png}}
		\caption{Karnaughova Mapa}
		\label{picture:KarnaughMap}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\centering
		{\includegraphics{obrazky-figures/logicalCircuit.png}}
		\caption{Logický obvod}
		\label{picture:logicalCircuit}
	\end{minipage}
\end{figure}

V technických odvetviach sa využívajú určité štandardné výrazy, ktoré sa dajú dobre využiť pri vytváraní kombinačných obvodov. Tieto výrazy sa nazývajú normálne formy a existuje ich niekoľko. Rôznymi typmi normálnych foriem sa zaoberá sekcia \ref{normal-forms}.

Pre strojovú reprezentáciu Booleovskych funkcií sa ukázali vhodné aj binárne rozhodovacie diagramy (BDD) a ich rôzne modifikácie, bude im venovaná samostatná sekcia \ref{bdds}.

\section{Normálne formy} \label{normal-forms}
Normálna forma je každý výraz v tvare:

$$T_1 \quad op \quad T_2 \quad op \quad T_3 \quad op \quad \ldots \quad op \quad T_n$$

kde množina $\{T_1,T_2,T_3 \ldots T_n\}$ sú navzájom rôzne termy rovnakého typu a $op$ je operácia v Boolovskej algebre.
Podľa typu termov a typu operácie poznáme niekoľko základných normálnych foriem. \cite{Hazewinkel-math}

\begin{itemize}
	\item disjunktívna - termy sú konjunkciou premenných a operáciou je disjunkcia
	\item konjunktívna - termy sú disjunkciou premenných a operáciou je konjunkcia  
\end{itemize}

Ak sa v každom terme v spomenutých normálnych formách vyskytuje premenná práve raz, tieto normálne formy nazývame úplná disjunktívna/konjunktívna normálna forma. 
Ak vynecháme redundantné členy, nazývame ich iredundantné normálne formy.

\section{Algebraická normálna forma}

Algebraická normálna forma (skrátene ANF) je jeden z možných spôsobov reprezentácie booleovskych funkcií. Ďalším používaným označením je Reed-Mullerova expanzia \cite{Muller-anf}\cite{Reed-anf}. Dnešné vedomosti o ANF pomáhali formovať aj Davio \cite{davio-anf} a Zhegalkin \cite{zhegalkin-anf}.  Je to jeden z najpoužívanejších sposobov reprezentácie v kryptografií. Podľa definície z knihy \textit{Boolean Functions and Their Applications in Cryptography} \cite{Feng-anf} je funkcia v ANF, ak je napísaná vo forme ako v \ref{eq_ANF_def}, kde $f(x)$ je daná funkcia, $c_0, c_i, c_{ij}, \dots,  c_{1,\dots,n}$ sú koeficienty o hodnote z množiny $\{0, 1\}$ a $\bigoplus$ reprezentuje operáciu XOR.

\begin{equation} \label{eq_ANF_def}
f(x) = c_0 \bigoplus_{1 \leq i \leq n} c_ix_i \bigoplus_{1 \leq i \leq j \leq n} c_{ij}x_ix_j \bigoplus \dots \bigoplus c_{1,\dots,n}x_1x_2\dots x_n
\end{equation}

Matematicky je dokázané, že pre každú booleovsku funkciu s danými konkrétnymi koeficientami sa dá vytvoriť unikátna ANF.

Celá ANF má taktiež hodnotu z množiny $\{0, 1\}$. Jednotlivé výrazy medzi operátormi XOR nazývame termy. Termy v ANF vytvárame buď kombináciou premenných spojených operáciou AND  a vynásobením koeficientami, prípadne to može byť jeden samostatný koeficient, ak sa v terme premenná nevyskytuje. Príklad možeme vidieť v \ref{eq_ANF_example}. Ako vidíme, ANF sa skladá len z kombinácie operácií AND a XOR, žiadna ďalšia booleovska operácia nie je povolená. Špecificky spomeniem operáciu NOT, ktorá sa bežne vyskytuje v ostatných normálnych formách ako sú DNF a CNF, ale v ANF nie je povolená. 
%Iný názov pre zápis v ANF je aj Zhegalkinov polynóm alebo Reed-Mullerov výraz.
	
\begin{equation} \label{eq_ANF_example}
1 \quad \bigoplus \quad A \quad \bigoplus \quad B \quad \bigoplus \quad AB \quad \bigoplus \quad ABC
\end{equation}

Ďalej Wu a Feng uvádzajú \cite{Feng-anf}, že počet premenných jedného termu sa nazýva algebraický stupeň termu. Celkový algebraický stupeň celej ANF je stupeň termu s najvyššou hodnotou z danej ANF, ale berú sa len termy s nenulovými koeficientami. Používaná notácia pre algebraický stupeň funkcie je $deg(f)$. Najvyšší možný stupeň booleovskej funkcie o $n$ premenných je $n$, a to len vtedy ako sa v ANF nachádza term, ktorý obsahuje všetkých $n$ premenných.

Algebraický stupeň funkcie sa používa na určenie typu funkcie. Ak je stupeň nulový, funkcia je konštantná (neobsahuje žiadne premenné). Ak je stupeň 1, funkciu nazývame afínnou, a existuje ešte prípad, ak máme afínnnu funkciu bez konštantného termu $c_0$ z definície \ref{eq_ANF_def}, vtedy funkciu nazývame lineárnou. Lineárna funkcia teda prechádza bodom [0,0], afínna nemusí. Afínna booleovska funkcia je teda buď lineárna alebo lineárna XOR konštanta 1. Takže obe varianty sa vlastne možu považovať za lineárne.

Z programátorského pohľadu môžeme hodnotu každého termu reprezentovať ako integer modulo 2. Každý term je 
%v terminológií podľa {\color{red} ODKAZ} 
jednoduchým polynómom, ktorý v sebe neobsahuje koeficienty ani exponenty. Koeficienty nepotrebujeme, pretože 1 je jediný nenulový koeficient. Exponenty nie sú potrebné z dovodu, že každá individuálna premenná v ANF má algebraický stupeň najviac 1, keďže platí, že $x^n = x$, v nezávislosti na tom, či $x = 1$ alebo $x = 0$. Preto napríklad aj zložitejší polynóm ako $3^x 2^y 5^z$ môžeme prepísať na $xyz$ a jednoducho ho reprezentovať v programe.
	
\vspace*{0.5\baselineskip}
Pomocou operácií AND $\wedge$ a NOT $\neg$ dokážeme vytvoriť všetky ostatné operácie v Booleovskej algebre. Ďalšie operácie sú tvorené len kombináciou týchto dvoch operácií. Keďže v ANF je nie povolená operácia NOT, musíme si ju nejako vytvoriť. Negácia v ANF vzniká XORom premennej a logickej jedničky: x $\bigoplus$ 1. Týmto sposobom dokážeme previesť do ANF aj funkcie z iných normálnych foriem, prípadne aj z iných reprezentácií.

TODO:
\begin{itemize}
	\item porovnanie s CNF a DNF
	\item riesenie bf
	\item konverzie
	\item boolean satisfiability
\end{itemize}

\section{Binárne rozhodovacie diagramy} \label{bdds}
Binárne rozhodovacie diagramy (BDD) sú triedou grafov, ktorá je prevažne využívaná ako dátová štruktúra pre reprezentáciu Booleovskych funkcií v dnešnej dobe. Existujú viaceré implementácie, ktoré sú postavené práve na BDD. Používajú sa na riešenie problémov ekvivalencie a splniteľnosti výrazov. Sú veľmi dôležité v oblastiach HW designu a optimalizácie.  

%\vspace*{0.5\baselineskip}
%Pre BDD platia tieto pravidlá:
%\begin{itemize}
%	\item BDD obsahuje práve 1 uzol, ktorý nemá žiadnych predchodcov - nazývame ho koreň
%	\item obsahuje 1 alebo 2 uzly, ktoré nemajú ďalších nasledovníkov (označuje 0, resp. 1)
%	\item všetky ostatné uzly sú označené názvom premennej a majú práve 2 nasledovníkov: {\color{red} 0-child a 1-child}, hrany vedúce k týmto nasledovníkom sú označené 0 a 1
%	\item každý synovský uzol je označený buď ako 0,1 alebo premennou vyššou ako označenie otcovského uzlu.
%\end{itemize}

%Označenie BDD sa často používa pre označenie iného typu binárneho rozhodovacieho diagramu, a to ROBDD (Reduced Ordered BDD). V podstate sa jedná o optimalizovaný klasický BDD. Pre ROBDD platia 2 pravidlá oproti BDD:

%\begin{itemize}
%	\item ordered - ak sa premenné na rôznych cestách v diagramu vyskytujú všade v rovnakom poradí
%	\item reduced - všetky izomorfné podgrafy sú spojené, a každý uzol, ktorého deti sú izomorfné je zanedbaný
%\end{itemize} 

\chapter{Existujúce knižnice} \label{chapter_libraries}
Existuú viaceré knižnice vytvorené za účelom manipulácie s Booleovskymi funkciami. Nasledujúca kapitola sa zaoberá niektorými vybranými, hlavne tými, ktoré využívajú binárne rozhodovacie stromy (BDD).

\section{Colorado University Decision Diagram
	Package - CUDD}
	CUDD je verejne dostupná knižnica\footnote{ \url{http://vlsi.colorado.edu/~fabio/} }, ktorej vývoj sa začal už v 70. rokoch a naďalej pokračuje.
	
	\vspace*{0.5\baselineskip}
	Balíček je možné využívať ako tzv. \textit{black box}, teda používať len exportované funkcie, ale aj ako tzv. \textit{clean box}, kde si programátor vie dodať vlastné doplňujúce funkcie.
	
	\vspace*{0.5\baselineskip}
	Je napísaná v jazyku C a poskytuje funkcie pre manipuláciu s BDD, s algebraickými rozhodovacími diagramami (ADD, MTBDD) a s diagramami s potlačenou nulou (ZDD). Takisto poskytuje možnosť prevádzať medzi jednotlivými typmi diagramov.
	
	\vspace*{0.5\baselineskip}
	CUDD využíva ukazovatele na uzly BDD. Udržuje si počítadlo referencií. Počet premenných ovplyvňuje počet tabuliek. Knižnica využíva heuristiku, ktorá sprístupní tabuľku výpočtov len vtedy, ak aspoň jeden argument má hodnotu počítadla referencií väčšiu než 1.
	
	\vspace*{0.5\baselineskip}
	V CUDD existuje veľmi efektívny správca pamäte. Garbage Collector podľa počítadla referencií maže \textit{mrtvé uzly}, teda uzly, ktoré majú 0 v počítadle referencií.
	
	Ďalšie informácie o knižnici sa dajú dohľadať v manuáli \cite{CUDD-manual}.
	
	\section{CacBDD}
	Knižnica CacBDD je verejne dostupná\footnote{ \url{http://kailesu.net/CacBDD/}} podobne ako knižnica CUDD, narozdiel od nej je ale implementovaná v jazyku C++. Je založená na prehľadávaní do hĺbky.
	 
	\vspace*{0.5\baselineskip}
	Poskytuje základné operácie pre manipuláciu s BDD. BDD uzly sú uložené v jednom poli a využíva indexy uzlov v tomto poli namiesto ukazateľov na uzly ako tomu je v CUDD. Nevyužíva počítadlo referencií na uzly. Garbace collector je volaný len ak dôjde pamäť. Funguje trošku inak ako v prípade CUDD, prechádza všetky uzly v poli, a tie na ktoré sa nikto neodkazuje a ani nie sú koreňmi, označí ako voľné uzly, nemaže ich a tým šetrí výpočtový čas. Knižnica využíva dynamické zväčšovanie tabuľky výpočtov podľa potreby, ak dôjde počet voľných miest. V knižnice je veľmi dobre implementované ukladanie medzivýsledkov, čo takisto pridáva na rýchlosti.
	
	\vspace*{0.5\baselineskip}
	Ďalšie informácie sú popísané v manuáli \cite{CacBDD-manual}, kde aj ukázané, že knižnica pracuje rýchlejšie než knižnica CUDD.

\section{BuDDy}
	Knižnica BuDDy je ďalšou knižnicou na prácu s Booleovskymi výrazmi. Je naprogramovaná v jazyku C, ale obsahuje obaľovacie C++ rozhranie pre jednoduchšiu prácu. 
	
	\vspace*{0.5\baselineskip}
	Obsahuje vlastný Garbage Collector, cache pamäť na uchovanie medzivýsledkov. Takmer každé nastavenie činnosti sa dá ručne prenastaviť, ale obsahuje aj základné nastavenia pre užívateľov, ktorí sa v nastaveniach hrabať nechcú.

	\vspace*{0.5\baselineskip}
	Knižnica obsahuje veľké množstvo funkcií a operácií, ktoré sa dajú použiť na prácu s Booleovskymi funkciami. Všetky výsledky v BuDDy sú reprezentované vektormi, a tým pádom sa s nimi v C++ ľahšie manipuluje.
	
	\section{BCL - Class Library for Boolean Function Manipulation}
	Knižnica pre manipuláciu s Booleovskymi funkciami vytvorená v jazyku C\#, je vhodná pre využitie v jazykoch z rodiny .NET Framework. 
	
	\vspace*{0.5\baselineskip}
	Obsahuje viaceré interné reprezentácie Booleovskych funkcií, ako sú pravdivostné tabuľky, booleovske výrazy a BDD.  Každá z reprezentácií obsahuje metódy na zjednodušenie funkcie, vytvorenie novej funkcie aplikovaním operátoru na 2 funkcie, na nahradenie premennej konštantou a pre nahradenie premennej inou funkciou.
	
	\vspace*{0.5\baselineskip}
	Knižnica sa využíva hlavne na výskumné účely, pretože obsahuje užitočné funkcie na určenie Shannonovho rozvoja, zistenie linearity a monotónnosti funkcie a mnohé ďalšie.
	Takisto obsahuje metódy konverzie medzi reprezentáciami, okrem iných aj konvertor z pravdivostnej tabuľky na ANF, DNF, CNF a BDD.
	
	
	\section{CORAL}
	Knižnica napísaná v jazyku C++, ktorá bola zamýšľaná na použitie v logických programovacích jazykoch, ale aj v iných. Podobne ako ostatné knižnice využíva ROBDD - Reduced Ordered BDD. Knižnica je zameraná hlavne na pamäťovú efektivitu a na optimalizáciu.
	
	\section{BDD}
	Knižnica napísaná v C, primárne zameraná na operačné systémy UNIX, pre prácu mimo UNIX je potrebné upraviť správcu pamäte. Knižnica je rozsahovo veľmi malá\footnote{ \url{http://www.cs.cmu.edu/afs/cs/project/modck/pub/www/bdd.html} }. 
	
	\vspace*{0.5\baselineskip}
	Obsahuje nástroje na sekvenčné overovanie, cache pamäť na ukladanie výsledkov, kam sa ukladajú úplne všetky medzivýsledky, kvantifikácie viacerých premenných a substitúcie. Okrem toho obsahuje nástroje na analýzu BDD, napríklad histogram, možnosť uloženia BDD do súborov.
	
	\vspace*{0.5\baselineskip}
	Garbage collector funguje na báze počítadla referencií alebo na princípe "zmaž všetko okrem". Takisto používateľ dokáže nastaviť limit na počet uzlov, operácie samé zmažú pamäť ak by museli prekročiť tento limit. Knižnica poskytuje aj možnosť dynamického preusporiadania premenných.

\section{PPBF BDD - Parallel partial breadth-first expansion}
	Knižnica\footnote{\url{http://www.cs.cmu.edu/~bwolen/software/} } pre multiprocesorové paralelné spracovanie BDD. Na prácu potrebuje zdieľanú pamäť. Poskytuje operácie nad kombinačnými obvodmi. 
	
\chapter{Návrh}
V tejto kapitole si bližšie popíšeme návrh knižnice pre manipuláciu s booleovskymi funkciami v ANF. Vysvetlíme si ako efektívne reprezentovať všetky časti booleovskej funkcie v programe. Takisto si navrhneme všetky potrebné operácie pre reprezentáciu funkcie v ANF. 

Základné vlastnosti, ktoré sa od knižnice požadujú sú efektívna reprezentácia a manipulácia s booleovskymi funkciami. Knižnica by mala obsahovať nástroje použiteľné na vytváranie, úpravu, zobrazovanie a mazanie funkcií a ich jednotlivých súčastí.

Ďalšou požiadavkou na knižnicu je určite čo najefektívnejšia práca s pamäťou, a takisto aj rýchlosť pri manipulácií s veľkým počtom funkcií, prípadne premenných vo funkciách.

\section{Voľba technológií}
Väčšina existujúcich knižníc pre manipuláciu s booleovskymi funkciami bola vytvorená v programovacom jazyku C, prípadne C++. Pri tvorbe knižnice je treba dbať na rýchlosť a pamäťové nároky, preto sme si zvolili jazyk C. Programovacie jazyky vyššej úrovne sme odmietli z dôvodu, že v C sa dajú dosiahnuť najlepšie výsledky práve v týchto 2 kategóriách.

Ako platformu pre vývoj knižnice sme podobne ako existujúce riešenia zvolili UNIX.

\section{Reprezentácia premenných}
Každá booleovska funkcia obsahuje 0 až n premenných, ktoré je potrebné efektívne reprezentovať. Každá premenná má svoje pomenovanie a booleovskú hodnotu. Povolená dlžka názvu premennej by mala byť dostatočná, aby sme dokázali unikátne reprezentovať veľký počet premenných.

\vspace*{0.5\baselineskip}
\begin{lstlisting}[language=C, frame=tb]
  typedef struct variable {
    char* name;
    bool value;
  } tVar;
\end{lstlisting}

\vspace*{0.5\baselineskip}
Premenné sa môžu vyskytovať v jednotlivých termoch funkcie opakovane, a takisto premenná môže byť súčasťou viacerých termov vo funkcii. Keďže má premenná vo všetkych svojich výskytoch rovnakú booleovskú hodnotu, je potrebné zaistiť, aby sa takéto duplicitné výskyty neukladali do pamäte opakovane.

Obor všetkých premenných je možné reprezentovať viacerými spôsobmi. Klasické pole poskytuje výhodu, že operácia vyhľadávania je rýchla, ak vieme presný index, na ktorý chceme pristúpiť. To by bolo využiteľné, ak by premenné v booleovskej funkcií mali len číselný index, a generovali sa od najnižších indexov po najvyššie (aby sme zbytočne nealokovali pamäť o väčšej veľkosti než je potrebná). V našom prípade by premenné mali mať ľubovoľné pomenovanie, a teda tento postup sa ukázal ako nevhodný.

Druhým spôsobom je použitie hashovacej tabuľky. Tá rieši vyššie spomenutý problém, pretože ak poznáme kľúč k danému záznamu, prístup k jeho hodnote je veľmi rýchly, v závislosti na hashovacej funkcii. V hashovacej tabuľke je možné zaistiť aj riešenie problému s ukladaním duplicitných záznamov, a to kontrolou, či záznam s daným kľúčom už v tabuľke existuje.

\section{Hashovacia tabuľka premenných}
Keďže v jazyku C neexistuje štruktúra ako hashovacia tabuľka, je potrebné nejakú vytvoriť. Kľúčom ku korektnému správaniu je voľba správnej hashovacej funkcie pre účely knižnice.

Primárnym účelom knižnice je jej využitie v obvodovej štruktúre tvorenej spätnoväzobným registrom ... ({\color{red}TODO}). Pre tieto účely nie je potrebné šifrovať záznamy v hashmapy, keďže by sa malo jednať o čo najjednoduchšiu implementáciu. Preto sme sa rozhodli vyberať z nešifrovaných hashovacích funkcií, a podľa požadovaných parametrov zvoliť najlepšiu alternatívu.

Existuje veľké množstvo voľne dostupných samostatných implementácií hashovacej tabuľky. Nástroj SMHasher\footnote{\url{https://github.com/aappleby/smhasher}} a jeho rozšírená verzia\footnote{\url{https://github.com/rurban/smhasher}} poskytujú dobré porovnanie existujúcich hashovacích algoritmov.

Analýzou SMHasherom ako jedny z najlepších prešli hashovacie algoritmy Spooky32, xxHash64 a fasthash.

{\color{red}
	TODO - prečo som použil čo som použil
}

Výsledná hashovacia tabuľka by mala obsahovať okrem záznamov aj záznam o celkovej kapacite a o aktuálne využitej kapacite. Takisto v prípade, že záznamy zaplnia určité percento tabuľky, je potrebné kapacitu tabuľky zväčšiť a záznamy prehashovať. Tento bod si nazveme load factor a budeme ho reprezentovať číslom v intervale [0,1]. Každý záznam obsahuje informáciu, či existuje premenná booleovskej funkcie, ktorej hodnota sa mapuje do daného záznamu.

\vspace*{0.5\baselineskip}
\begin{lstlisting}[language=C, frame=tb]
  typedef struct hashMapRecord {
    char* key;
    bool value;
    bool used;
  } tHashMapRecord;
  
  typedef struct hashMap {
    tHashMapRecord *records;
    int capacity;
    int usedCapacity;
    double loadFactor;
  } tHashMap;
\end{lstlisting}

\section{Reprezentácia termov}
Každá booleovska funkcia v ANF sa skladá z 0 až n termov, ktoré obsahujú premenné. Premenné v terme sú medzi sebou prepojené operáciou AND. Každý term by mal v sebe obsahovať informácie, ktoré premenné obsahuje a koľko ich je dokopy. Keďže medzi všetkým premennými je rovnaká operácia, nie je potrebné si uchovávať informáciu o tom, na ktorej pozícií v terme sa nachádza ktorá premenná. Je teda možné premenné reprezentovať jednoduchým zoznamom. 

Premenné by malo byť do termu možné dynamicky vkladať, takisto ich z neho odoberať. Term môže obsahovať jednu premennú aj viackrát.

Každý term má aj svoju celkovú výslednú booleovsku hodnotu, ktorá je vypočítaná vykonaním operácie AND medzi všetkými premennými. Je dôležité myslieť na to, že ak budú do termu pridávané, alebo z neho odoberané premenné, mala by sa prepočítať aj táto výsledná hodnota. 

Term už nemusí obsahovať priamo celé premenné, tie sú už uložené v hash mape celej ANF, v terme postačuje mať záznamy o názvoch premenných, ich hodnoty sa vytiahnu z hash mapy. Návrh štruktúry termu by mohol vyzerať nasledovne:  

\vspace*{0.5\baselineskip}
\begin{lstlisting}[language=C, frame=tb]
  typedef struct node {	
    char** variables;
    int varCount;
    bool value;
  } tNode;
\end{lstlisting}

\vspace*{0.5\baselineskip}
\section{Reprezentácia booleovskej funkcie}
Štruktúra reprezentujúca booleovsku funkciu obsahuje všetky potrebné informácie o svojom obsahu. Obsahuje zoznam termov, ktoré sa vo funkcii nachádzajú, a takisto informáciu o tom, koľko je termov dohromady vo funkcii. Keďže všetky termy v booleovskej funkcii vo forme ANF sú spojené operáciou XOR, nie je potrebné si uchovávať informáciu o poradí termu vo funkcií.

Ďalej je v štruktúre obsiahnutá aj hashovacia tabuľka, obsahujúca všetky hodnoty premenných, ktoré sa v booleovskej funkcií vyskytujú. Hashovacia tabuľka je spoločná pre celú booleovsku funkciu.

Okrem spomenutých je potrebné v štruktúre zachovať informáciu o aktuálnej hodnote celej funkcie, vypočítanú vykonaním operácie XOR nad jednotlivými termami funkcie. Hodnota sa musí meniť správne podľa toho, ako sa manipuluje s termami. Či už sa termy pridávajú alebo odoberajú, alebo sa menia hodnoty premenných, hodnota celej funkcie musí byť uchovaná správne po celý čas.

\vspace*{0.5\baselineskip}
\begin{lstlisting}[language=C, frame=tb]
typedef struct anf {
	tNode** nodeList;
	tHashMap* hashMap;
	int nodeCount;
	bool value;
} tAnf;
\end{lstlisting}

\chapter{Implementácia}
\chapter{Vyhodnotenie}
\chapter{Záver}

TODO
Možné rozšírenie: 

Zadanie explicitne špecifikuje, že sa knižnica bude zaoberať manipuláciou booleovskych funkcií v ANF, preto pri navrhovaní knižnice bude na to braný zreteľ. Možným rozšírením by bolo vytvorenie konvertoru, ktorý by dokázal dostať na vstup booleovsku funkciu aj v inej reprezentácií ako je ANF, skonvertovať ju na ANF a ďalej potom pracovať s knižnicou. Toto rozšírenie je však ponechané mimo tejto práce.

rozšírenie pre iné platformy?

rozne hash funkcie?
	
	
\chapter{TODO}	
				
BDD:
	\begin{itemize}
		\item  Graph-Based Algorithms for Boolean Function Manipulation, Randal E. Bryant, 1986
		\item C. Y. Lee. "Representation of Switching Circuits by Binary-Decision Programs". Bell System Technical Journal, 38:985–999, 1959.
		\item Sheldon B. Akers. Binary Decision Diagrams, IEEE Transactions on Computers, C-27(6):509–516, June 1978.
		\item Raymond T. Boute, "The Binary Decision Machine as a programmable controller". EUROMICRO Newsletter, Vol. 1(2):16–22, January 1976.
		\item Randal E. Bryant. "Graph-Based Algorithms for Boolean Function Manipulation". IEEE Transactions on Computers, C-35(8):677–691, 1986.
		\item R. E. Bryant, "Symbolic Boolean Manipulation with Ordered Binary Decision Diagrams", ACM Computing Surveys, Vol. 24, No. 3 (September, 1992), pp. 293–318.
		\item Karl S. Brace, Richard L. Rudell and Randal E. Bryant. "Efficient Implementation of a BDD Package". In Proceedings of the 27th ACM/IEEE Design Automation Conference (DAC 1990), pages 40–45. IEEE Computer Society Press, 1990.
		\item http://scpd.stanford.edu/knuth/index.jsp
		\item R.M. Jensen. "CLab: A C+ + library for fast backtrack-free interactive product configuration". Proceedings of the Tenth International Conference on Principles and Practice of Constraint Programming, 2004.
		\item H.L. Lipmaa. "First CPIR Protocol with Data-Dependent Computation". ICISC 2009.
		\item Beate Bollig, Ingo Wegener. Improving the Variable Ordering of OBDDs Is NP-Complete, IEEE Transactions on Computers, 45(9):993–1002, September 1996.
		\item Detlef Sieling. "The nonapproximability of OBDD minimization." Information and Computation 172, 103–138. 2002.
		\item Rice, Michael. "A Survey of Static Variable Ordering Heuristics for Efficient BDD/MDD Construction" (PDF).
		\item Philipp Woelfel. "Bounds on the OBDD-size of integer multiplication via universal hashing." Journal of Computer and System Sciences 71, pp. 520-534, 2005.
		\item Richard J. Lipton. "BDD's and Factoring". Gödel's Lost Letter and P=NP, 2009.
		\item Andersen, H. R. (1999). "An Introduction to Binary Decision Diagrams" (PDF). Lecture Notes. IT University of Copenhagen.
	\end{itemize}
	
KNF:
	\begin{itemize}
		\item Paul Jackson, Daniel Sheridan: Clause Form Conversions for Boolean Circuits. In: Holger H. Hoos, David G. Mitchell (Eds.): Theory and Applications of Satisfiability Testing, 7th International Conference, SAT 2004, Vancouver, BC, Canada, May 10–13, 2004, Revised Selected Papers. Lecture Notes in Computer Science 3542, Springer 2005, pp. 183–198
		\item G.S. Tseitin: On the complexity of derivation in propositional calculus. In: Slisenko, A.O. (ed.) Structures in Constructive Mathematics and Mathematical Logic, Part II, Seminars in Mathematics (translated from Russian), pp. 115–125. Steklov Mathematical Institute (1968)
	\end{itemize}
DNF:
\begin{itemize}
	\item  B.A. Davey and H.A. Priestley (1990). Introduction to Lattices and Order. Cambridge Mathematical Textbooks. Cambridge University Press.
\end{itemize}
Majority function:
\begin{itemize}
	\item Knuth, Donald E. (2008). Introduction to combinatorial algorithms and Boolean functions. The Art of Computer Programming. 4a. Upper Saddle River, NJ: Addison-Wesley. pp. 64–74. ISBN 0-321-53496-4.
\end{itemize}
Reed Muller:
\begin{itemize}
	\item Kebschull, U. and Rosenstiel, W., Efficient graph-based computation and manipulation of functional decision diagrams, Proceedings 4th European Conference on Design Automation, 1993, pp. 278–282
\end{itemize}
other:
\begin{itemize}
	\item Stone, Marshall (1936). "The Theory of Representations for Boolean Algebras". Transactions of the American Mathematical Society. Transactions of the American Mathematical Society, Vol. 40, No. 1. 40 (1): 37–111. doi:10.2307/1989664. ISSN 0002-9947. JSTOR 1989664.
\end{itemize}